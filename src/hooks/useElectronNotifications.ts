import { useEffect, useCallback, useRef } from 'react';
import { Check, Settings, NotificationHistory } from '../types';
import { isToday, isDateInRange, getDaysUntilPayment } from '../utils/dateUtils';
import { useMedications } from './useMedications';

export function useElectronNotifications(checks: Check[], settings: Settings) {
  const isElectron = typeof window !== 'undefined' && window.electronAPI;
  const lastCheckRef = useRef<string>('');
  
  // ƒ∞la√ß hook'u
  const { getTodaySchedule, getUpcomingMedications } = useMedications();

  // Bildirim ge√ßmi≈üini localStorage'dan y√ºkle/kaydet
  const getNotificationHistory = (): NotificationHistory[] => {
    try {
      const history = localStorage.getItem('hatirlatici-notification-history');
      return history ? JSON.parse(history) : [];
    } catch {
      return [];
    }
  };

  const saveNotificationHistory = (history: NotificationHistory[]) => {
    try {
      localStorage.setItem('hatirlatici-notification-history', JSON.stringify(history));
    } catch (error) {
      console.error('Bildirim ge√ßmi≈üi kaydedilemedi:', error);
    }
  };

  // Bildirim g√∂nderme fonksiyonu (Telegram entegrasyonu electron.cjs'te yapƒ±ldƒ±)
  const showNotification = useCallback(async (title: string, body: string) => {
    try {
      if (isElectron && window.electronAPI) {
        // Electron √ºzerinden hem masa√ºst√º hem telegram bildirimi g√∂nderilir
        await window.electronAPI.showNotification(title, body);
      } else if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, {
          body,
          icon: '/vite.svg',
          requireInteraction: true,
        });
      }
    } catch (error) {
      console.error('Bildirim g√∂nderilemedi:', error);
    }
  }, [isElectron]);

  // Web notification izni iste
  const requestPermission = useCallback(async () => {
    if (!isElectron && 'Notification' in window && Notification.permission === 'default') {
      await Notification.requestPermission();
    }
  }, [isElectron]);

  // Belirli bir check veya medication i√ßin bildirim g√∂nderilmi≈ü mi kontrol et
  const hasNotificationBeenSent = (
    checkId: string, 
    notificationType: 'reminder' | 'due-today' | 'daily' | 'medication',
    paymentDate: string,
    medicationId?: string
  ): boolean => {
    const history = getNotificationHistory();
    
    if (notificationType === 'daily') {
      // G√ºnl√ºk bildirimler i√ßin sadece bug√ºn g√∂nderilmi≈ü mi bak
      const today = new Date().toDateString();
      return history.some(h => 
        h.checkId === checkId && 
        h.notificationType === 'daily' &&
        new Date(h.sentAt).toDateString() === today
      );
    } else {
      // Reminder ve due-today i√ßin √∂deme tarihine g√∂re kontrol et
      return history.some(h => 
        h.checkId === checkId && 
        h.notificationType === notificationType &&
        h.paymentDate === paymentDate
      );
    }
  };

  // Bildirim g√∂nder ve ge√ßmi≈üe kaydet (hem √∂deme hem ila√ß i√ßin)
  const sendNotificationWithHistory = (
    check: Check | null,
    notificationType: 'reminder' | 'due-today' | 'daily' | 'medication',
    title: string,
    body: string,
    medicationId?: string
  ) => {
    // Zaten g√∂nderilmi≈ü mi kontrol et
    const id = check ? check.id : medicationId || 'unknown';
    const paymentDate = check ? check.paymentDate : new Date().toISOString().split('T')[0];
    
    if (hasNotificationBeenSent(id, notificationType, paymentDate, medicationId)) {
      return;
    }

    // Bildirimi g√∂nder (Telegram entegrasyonu electron.cjs'te otomatik)
    showNotification(title, body);

    // Ge√ßmi≈üe kaydet
    const history = getNotificationHistory();
    const newEntry: NotificationHistory = {
      checkId: check ? check.id : (medicationId || 'unknown'),
      notificationType,
      sentAt: new Date().toISOString(),
      paymentDate: check ? check.paymentDate : new Date().toISOString().split('T')[0],
      medicationId: medicationId,
    };
    
    history.push(newEntry);
    
    // Eski kayƒ±tlarƒ± temizle (30 g√ºnden eski)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const cleanHistory = history.filter(h => 
      new Date(h.sentAt) > thirtyDaysAgo
    );
    
    saveNotificationHistory(cleanHistory);
  };

  // G√ºnl√ºk bildirim saati geldi mi kontrol et
  const isDailyNotificationTime = (): boolean => {
    if (!settings.dailyNotificationEnabled) return false;
    
    const now = new Date();
    const [hours, minutes] = settings.dailyNotificationTime.split(':').map(Number);
    
    const currentTime = now.getHours() * 60 + now.getMinutes();
    const targetTime = hours * 60 + minutes;
    
    // ¬±5 dakika tolerans
    return Math.abs(currentTime - targetTime) <= 5;
  };

  // Son g√ºnl√ºk kontrol bug√ºn yapƒ±ldƒ± mƒ±?
  const wasDailyCheckDoneToday = (): boolean => {
    const lastCheck = settings.lastNotificationCheck;
    if (!lastCheck) return false;
    
    const today = new Date().toDateString();
    const lastCheckDate = new Date(lastCheck).toDateString();
    
    return today === lastCheckDate;
  };

  // Hatƒ±rlatma ve √∂deme g√ºn√º bildirimlerini kontrol et
  const checkReminderNotifications = useCallback(() => {
    if (!settings.notificationsEnabled) return;

    checks.forEach(check => {
      if (check.isPaid) return;

      const type = check.type === 'bill' ? 'Fatura' : '√áek';
      const company = check.signedTo;
      const amount = check.amount.toLocaleString('tr-TR');

      // Hatƒ±rlatma bildirimi (X g√ºn √∂nceden)
      const daysUntil = getDaysUntilPayment(check.paymentDate, check.nextPaymentDate, check.isRecurring);
      if (daysUntil > 0 && daysUntil <= settings.reminderDays) {
        const daysLeft = daysUntil;
        
        sendNotificationWithHistory(
          check,
          'reminder',
          `üí∞ ${type} √ñdeme Hatƒ±rlatmasƒ±`,
          `${company} - ${amount} TL tutarƒ±ndaki ${type.toLowerCase()}in √∂deme tarihi ${daysLeft} g√ºn sonra`
        );
      }

      // √ñdeme g√ºn√º bildirimi
      const checkDateToCheck = check.isRecurring && check.nextPaymentDate ? check.nextPaymentDate : check.paymentDate;
      if (isToday(checkDateToCheck)) {
        sendNotificationWithHistory(
          check,
          'due-today',
          `üî¥ ${type} √ñdeme G√ºn√º!`,
          `${company} - ${amount} TL tutarƒ±ndaki ${type.toLowerCase()}in √∂deme g√ºn√º bug√ºn!`
        );
      }
    });
  }, [checks, settings, showNotification]);

  // ƒ∞la√ß bildirimlerini kontrol et
  const checkMedicationNotifications = useCallback(() => {
    if (!settings.medicationNotificationsEnabled) return;

    const todaySchedule = getTodaySchedule();
    const now = new Date();
    const reminderMinutes = settings.medicationReminderMinutes || 15;

    todaySchedule.medications.forEach(item => {
      if (item.status !== 'pending') return; // Sadece bekleyen ila√ßlar

      // Planlanan saat
      const scheduledDateTime = new Date(`${todaySchedule.date}T${item.scheduledTime}`);
      
      // Hatƒ±rlatma zamanƒ± (X dakika √∂nceden)
      const reminderTime = new Date(scheduledDateTime.getTime() - reminderMinutes * 60 * 1000);
      
      // ≈ûimdi hatƒ±rlatma zamanƒ± mƒ±?
      const timeDiff = Math.abs(now.getTime() - reminderTime.getTime());
      const isReminderTime = timeDiff <= 2 * 60 * 1000; // 2 dakika tolerans

      if (isReminderTime) {
        sendNotificationWithHistory(
          null,
          'medication',
          `üíä ƒ∞la√ß Hatƒ±rlatmasƒ±`,
          `${item.medication.name} (${item.medication.dosage}) - ${reminderMinutes} dakika sonra alƒ±nacak`,
          item.medication.id
        );
      }

      // Tam zamanƒ± mƒ±?
      const isExactTime = Math.abs(now.getTime() - scheduledDateTime.getTime()) <= 2 * 60 * 1000;
      
      if (isExactTime) {
        sendNotificationWithHistory(
          null,
          'medication',
          `‚è∞ ƒ∞la√ß Zamanƒ±!`,
          `${item.medication.name} (${item.medication.dosage}) - ≈ûimdi alƒ±nacak!`,
          item.medication.id
        );
      }

      // Gecikmi≈ü ila√ßlar (30 dakika sonrasƒ±)
      const isLate = now.getTime() > scheduledDateTime.getTime() + 30 * 60 * 1000;
      
      if (isLate) {
        const minutesLate = Math.floor((now.getTime() - scheduledDateTime.getTime()) / (60 * 1000));
        sendNotificationWithHistory(
          null,
          'medication',
          `‚ö†Ô∏è ƒ∞la√ß Gecikmesi`,
          `${item.medication.name} - ${minutesLate} dakika gecikti`,
          item.medication.id
        );
      }
    });
  }, [settings, getTodaySchedule, sendNotificationWithHistory]);

  // G√ºnl√ºk bildirim kontrol√º
  const checkDailyNotifications = useCallback(() => {
    if (!settings.dailyNotificationEnabled || !settings.dailyNotificationTime) return;

    const now = new Date();
    const today = now.toDateString();
    
    // Bug√ºn zaten kontrol edildi mi?
    if (settings.lastNotificationCheck === today) return;

    // Ayarlanan saat geldi mi?
    const [hour, minute] = settings.dailyNotificationTime.split(':').map(Number);
    const targetTime = new Date();
    targetTime.setHours(hour, minute, 0, 0);
    
    // 5 dakika tolerans
    const timeDiff = Math.abs(now.getTime() - targetTime.getTime());
    if (timeDiff > 5 * 60 * 1000) return;

    // G√ºnl√ºk √∂zet bildirimi g√∂nder
    const unpaidChecks = checks.filter(c => !c.isPaid);
    const overdueChecks = unpaidChecks.filter(c => getDaysUntilPayment(c.paymentDate) < 0);
    const todayChecks = unpaidChecks.filter(c => {
      const checkDate = new Date(c.paymentDate);
      return checkDate.toDateString() === today;
    });

    let title = 'üìÖ G√ºnl√ºk √ñdeme Hatƒ±rlatƒ±cƒ±sƒ±';
    let body = '';

    if (overdueChecks.length > 0) {
      body += `‚ö†Ô∏è ${overdueChecks.length} gecikmi≈ü √∂deme var!\n`;
    }
    
    if (todayChecks.length > 0) {
      body += `üî¥ Bug√ºn ${todayChecks.length} √∂deme var\n`;
    }
    
    if (unpaidChecks.length > 0) {
      body += `üìã Toplam ${unpaidChecks.length} bekleyen √∂deme\n`;
      body += `üí∞ Toplam: ${unpaidChecks.reduce((sum, c) => sum + c.amount, 0).toLocaleString('tr-TR')} ‚Ç∫`;
    } else {
      body = 'üéâ T√ºm √∂demeler tamamlandƒ±!';
    }

    showNotification(title, body);
    
    // Son kontrol tarihini g√ºncelle
    if (window.electronAPI?.saveAppData) {
      window.electronAPI.saveAppData('settings', {
        ...settings,
        lastNotificationCheck: today
      });
    }
  }, [checks, settings, showNotification]);

  // Bilgisayar a√ßƒ±ldƒ±ƒüƒ±nda bildirim kontrol√º
  const checkStartupNotifications = useCallback(() => {
    if (!settings.notificationsEnabled) return;

    // Uygulama a√ßƒ±ldƒ±ktan 2 saniye sonra kontrol et
    setTimeout(() => {
      const unpaidChecks = checks.filter(c => !c.isPaid);
      const overdueChecks = unpaidChecks.filter(c => getDaysUntilPayment(c.paymentDate) < 0);
      const todayChecks = unpaidChecks.filter(c => {
        const checkDate = new Date(c.paymentDate);
        return checkDate.toDateString() === new Date().toDateString();
      });

      if (overdueChecks.length > 0) {
        showNotification(
          '‚ö†Ô∏è Gecikmi≈ü √ñdemeler Var!',
          `${overdueChecks.length} √∂deme vadesi ge√ßmi≈ü. Hemen kontrol edin!`
        );
      } else if (todayChecks.length > 0) {
        showNotification(
          'üî¥ Bug√ºn √ñdenecek √ñdemeler Var!',
          `${todayChecks.length} √∂deme bug√ºn vadesi doluyor.`
        );
      } else if (unpaidChecks.length > 0) {
        showNotification(
          'üìã Bekleyen √ñdemeler',
          `${unpaidChecks.length} √∂deme bekliyor. Toplam: ${unpaidChecks.reduce((sum, c) => sum + c.amount, 0).toLocaleString('tr-TR')} ‚Ç∫`
        );
      }
    }, 2000);
  }, [checks, settings, showNotification]);

  // ƒ∞zin isteme effect'i
  useEffect(() => {
    if (!isElectron) {
      requestPermission();
    }
  }, [requestPermission, isElectron]);

  // Ana bildirim kontrol effect'i
  useEffect(() => {
    // Sadece checks veya √∂nemli settings deƒüi≈ütiƒüinde √ßalƒ±≈ü
    const currentChecksum = JSON.stringify({
      checksCount: checks.length,
      notificationsEnabled: settings.notificationsEnabled,
      reminderDays: settings.reminderDays,
      dailyEnabled: settings.dailyNotificationEnabled,
      dailyTime: settings.dailyNotificationTime,
      telegramEnabled: settings.telegramBotEnabled, // Telegram ayarƒ± da checksum'a dahil
    });

    // Gereksiz re-run'larƒ± engelle
    if (lastCheckRef.current === currentChecksum) {
      return;
    }
    lastCheckRef.current = currentChecksum;

    // ƒ∞lk kontrolleri yap
    checkReminderNotifications();
    checkDailyNotifications();
    checkMedicationNotifications();
    checkStartupNotifications(); // Ba≈ülangƒ±√ßta da √ßalƒ±≈ütƒ±r

    // Periyodik kontroller i√ßin interval'lar
    const reminderInterval = setInterval(checkReminderNotifications, 60 * 60 * 1000); // Her saat
    const dailyInterval = setInterval(checkDailyNotifications, 5 * 60 * 1000); // Her 5 dakika
    const medicationInterval = setInterval(checkMedicationNotifications, 2 * 60 * 1000); // Her 2 dakika (ila√ß i√ßin daha hassas)

    return () => {
      clearInterval(reminderInterval);
      clearInterval(dailyInterval);
      clearInterval(medicationInterval);
    };
  }, [checkReminderNotifications, checkDailyNotifications, checkMedicationNotifications, checkStartupNotifications]);

  return { requestPermission, showNotification, isElectron };
}